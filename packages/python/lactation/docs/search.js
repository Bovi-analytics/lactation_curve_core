window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "lactationcurve", "modulename": "lactationcurve", "kind": "module", "doc": "<p>Lactation curve modelling and fitting package.</p>\n"}, {"fullname": "lactationcurve.PreparedInputs", "modulename": "lactationcurve", "qualname": "PreparedInputs", "kind": "class", "doc": "<p>Normalized, ready\u2011to\u2011fit inputs.</p>\n\n<p>This container is returned by <code>validate_and_prepare_inputs</code> and is the single\nhand\u2011off object expected by the fitting routines. Arrays are finite and 1\u2011dimensional;\ncategorical fields are lower/upper\u2011cased as appropriate and may be <code>None</code> if omitted.</p>\n\n<p>Attributes:\n    dim: 1D NumPy array of day\u2011in\u2011milk values (finite; same length as <code>milkrecordings</code>).\n    milkrecordings: 1D NumPy array of test\u2011day milk yields aligned to <code>dim</code>.\n    model: Lowercased model identifier or <code>None</code> if not provided.\n    fitting: <code>\"frequentist\"</code> or <code>\"bayesian\"</code> (lowercased) or <code>None</code>.\n    breed: <code>\"H\"</code> or <code>\"J\"</code> or <code>None</code>.\n    parity: Lactation number as <code>int</code>, if provided; otherwise <code>None</code>.\n    continent: Prior source flag for Bayesian flows (<code>\"USA\"</code>, <code>\"EU\"</code>, <code>\"CHEN\"</code>), or <code>None</code>.\n    persistency_method: Either <code>\"derived\"</code> or <code>\"literature\"</code>, or <code>None</code>.\n    lactation_length: Integer horizon (e.g., 305), the string <code>\"max\"</code>, or <code>None</code>.</p>\n"}, {"fullname": "lactationcurve.PreparedInputs.__init__", "modulename": "lactationcurve", "qualname": "PreparedInputs.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">milkrecordings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fitting</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">breed</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">parity</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">continent</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">persistency_method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lactation_length</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "lactationcurve.PreparedInputs.dim", "modulename": "lactationcurve", "qualname": "PreparedInputs.dim", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "lactationcurve.PreparedInputs.milkrecordings", "modulename": "lactationcurve", "qualname": "PreparedInputs.milkrecordings", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "lactationcurve.PreparedInputs.model", "modulename": "lactationcurve", "qualname": "PreparedInputs.model", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str | None", "default_value": "None"}, {"fullname": "lactationcurve.PreparedInputs.fitting", "modulename": "lactationcurve", "qualname": "PreparedInputs.fitting", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str | None", "default_value": "None"}, {"fullname": "lactationcurve.PreparedInputs.breed", "modulename": "lactationcurve", "qualname": "PreparedInputs.breed", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str | None", "default_value": "None"}, {"fullname": "lactationcurve.PreparedInputs.parity", "modulename": "lactationcurve", "qualname": "PreparedInputs.parity", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int | None", "default_value": "None"}, {"fullname": "lactationcurve.PreparedInputs.continent", "modulename": "lactationcurve", "qualname": "PreparedInputs.continent", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str | None", "default_value": "None"}, {"fullname": "lactationcurve.PreparedInputs.persistency_method", "modulename": "lactationcurve", "qualname": "PreparedInputs.persistency_method", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str | None", "default_value": "None"}, {"fullname": "lactationcurve.PreparedInputs.lactation_length", "modulename": "lactationcurve", "qualname": "PreparedInputs.lactation_length", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int | str | None", "default_value": "None"}, {"fullname": "lactationcurve.standardize_lactation_columns", "modulename": "lactationcurve", "qualname": "standardize_lactation_columns", "kind": "function", "doc": "<p>Standardize column names and structure for lactation data.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>df_out : pd.DataFrame\n    Copy of df with standardized columns:\n    - DaysInMilk\n    - MilkingYield\n    - TestId</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">days_in_milk_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">milking_yield_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">test_id_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">default_test_id</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">max_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">305</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.validate_and_prepare_inputs", "modulename": "lactationcurve", "qualname": "validate_and_prepare_inputs", "kind": "function", "doc": "<p>Validate, normalize, and clean input data for lactation curve fitting.</p>\n\n<p>This function performs basic consistency checks on the provided\ndays-in-milk (DIM) and milk recording data, normalizes optional\ncategorical parameters, and removes observations with missing or\nnon-finite values. The cleaned and validated inputs are returned\nin a structured <code>PreparedInputs</code> object.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>dim : array-like\n    Days in milk corresponding to each milk recording.\nmilkrecordings : array-like\n    Milk yield measurements corresponding to <code>dim</code>.\nmodel : str or None, optional\n    Name of the lactation curve model. If provided, the name is\n    stripped of whitespace and converted to lowercase.\nfitting : str or None, optional\n    Fitting approach to be used. Must be either <code>\"frequentist\"</code>\n    or <code>\"bayesian\"</code> if provided.\nbreed : str or None, optional\n    Cow breed identifier. Must be <code>\"H\"</code> (Holstein) or <code>\"J\"</code>\n    (Jersey) if provided. Case-insensitive.\nparity : int or None, optional\n    Lactation number (parity). If provided, it is coerced to an\n    integer.\ncontinent : str or None, optional\n    Geographic region identifier. Must be one of <code>\"USA\"</code>,\n    <code>\"EU\"</code>, or <code>\"CHEN\"</code> if provided. Case-insensitive.</p>\n\n<p>Extra input for persistency calculation:\n    persistency_method (String): way of calculating persistency, options: 'derived' which gives the average slope of the lactation after the peak until the end of lactation (default) or 'literature' for the wood and milkbot model.\n    Lactation_length: string or int: length of the lactation in days to calculate persistency over, options: 305 = default or 'max'  uses the maximum DIM in the data, or an integer value to set the desired lactation length.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>PreparedInputs\n    A dataclass containing the cleaned numeric arrays (<code>dim</code>,\n    <code>milkrecordings</code>) and the normalized optional parameters.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If input arrays have different lengths, contain insufficient\n    valid observations, or if categorical parameters are invalid.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Observations with missing or non-finite values in either <code>dim</code> or\n<code>milkrecordings</code> are removed prior to model fitting. At least two\nvalid observations are required to proceed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim</span>,</span><span class=\"param\">\t<span class=\"n\">milkrecordings</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fitting</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">breed</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">parity</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">continent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">persistency_method</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lactation_length</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">lactationcurve</span><span class=\"o\">.</span><span class=\"n\">preprocessing</span><span class=\"o\">.</span><span class=\"n\">validate_and_standardize</span><span class=\"o\">.</span><span class=\"n\">PreparedInputs</span>:</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.ali_schaeffer_model", "modulename": "lactationcurve", "qualname": "ali_schaeffer_model", "kind": "function", "doc": "<p>Ali &amp; Schaeffer lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM). Use <code>t &gt;= 1</code> to avoid <code>log(0)</code>.\n    a: Intercept-like parameter (numerical).\n    b: Linear coefficient on scaled time <code>t/340</code> (numerical).\n    c: Quadratic coefficient on scaled time <code>t/340</code> (numerical).\n    d: Coefficient on <code>log(340/t)</code> (numerical).\n    k: Coefficient on <code>[log(340/t)]^2</code> (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n\n<p>Notes:\n    Uses <code>t_scaled = t / 340</code> and <code>log_term = ln(340 / t)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span>, </span><span class=\"param\"><span class=\"n\">k</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.bayesian_fit_milkbot_single_lactation", "modulename": "lactationcurve", "qualname": "bayesian_fit_milkbot_single_lactation", "kind": "function", "doc": "<p>Fit a single lactation using the MilkBot API.</p>\n\n<p>Args:\n    dim: List/array of DIM values.\n    milkrecordings: List/array of milk recordings (kg).\n    key: API key for MilkBot.\n    parity: Lactation number; values &gt;= 3 are treated as one group in priors.\n    breed: \"H\" (Holstein) or \"J\" (Jersey).\n    continent: Prior source:\n        - \"USA\"   \u2192 MilkBot USA priors\n        - \"EU\"    \u2192 MilkBot EU priors\n        - \"CHEN\"  \u2192 Chen et al. published priors</p>\n\n<p>Returns:\n    Dictionary with fitted parameters and metadata:\n        {\n            \"scale\": float,\n            \"ramp\": float,\n            \"decay\": float,\n            \"offset\": float,\n            \"nPoints\": int\n        }</p>\n\n<p>Raises:\n    requests.HTTPError: For unsuccessful HTTP response codes.\n    RuntimeError: If the response format is unexpected.</p>\n\n<p>Notes:\n    - When <code>continent == \"CHEN\"</code>, Chen et al. priors are included in the request payload.\n    - EU calls use the GCP EU endpoint; others use <code>milkbot.com</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim</span>,</span><span class=\"param\">\t<span class=\"n\">milkrecordings</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">parity</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">breed</span><span class=\"o\">=</span><span class=\"s1\">&#39;H&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">continent</span><span class=\"o\">=</span><span class=\"s1\">&#39;USA&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.brody_model", "modulename": "lactationcurve", "qualname": "brody_model", "kind": "function", "doc": "<p>Brody lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM).\n    a: Scale parameter (numerical).\n    k: Decay parameter (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">k</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.dhanoa_model", "modulename": "lactationcurve", "qualname": "dhanoa_model", "kind": "function", "doc": "<p>Dhanoa lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM).\n    a: Scale parameter (numerical).\n    b: Shape parameter (numerical).\n    c: Decay parameter (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n\n<p>Notes:\n    Formula: <code>y(t) = a * t ** (b * c) * exp(-c * t)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.dijkstra_model", "modulename": "lactationcurve", "qualname": "dijkstra_model", "kind": "function", "doc": "<p>Dijkstra lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM).\n    a: Scale parameter (numerical).\n    b: Growth parameter (numerical).\n    c: Saturation rate parameter (numerical).\n    d: Decay parameter (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n\n<p>Notes:\n    Formula: <code>y(t) = a * exp((b * (1 - exp(-c * t)) / c) - d * t)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.emmans_model", "modulename": "lactationcurve", "qualname": "emmans_model", "kind": "function", "doc": "<p>Emmans lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM).\n    a: Scale parameter (numerical).\n    b: Growth parameter (numerical).\n    c: Decay parameter (numerical).\n    d: Location parameter in nested exponential (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n\n<p>Notes:\n    Formula: <code>y(t) = a * exp(-exp(d - b*t)) * exp(-c*t)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.fischer_model", "modulename": "lactationcurve", "qualname": "fischer_model", "kind": "function", "doc": "<p>Fischer lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM).\n    a: Scale parameter (numerical).\n    b: Linear decline parameter (numerical).\n    c: Exponential decay parameter (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.fit_lactation_curve", "modulename": "lactationcurve", "qualname": "fit_lactation_curve", "kind": "function", "doc": "<p>Fit lactation data to a lactation curve model and return predictions.</p>\n\n<p>Depending on <code>fitting</code>:</p>\n\n<ul>\n<li><strong>frequentist</strong>: Fits parameters using <code>minimize</code> and/or <code>curve_fit</code>\nfor the specified <code>model</code>, then predicts over DIM 1\u2013305 (or up to <code>max(dim)</code> if greater).</li>\n<li><strong>bayesian</strong>: (MilkBot only) Calls the MilkBot Bayesian fitting API and\nreturns predictions using the fitted parameters.</li>\n</ul>\n\n<p>Args:\n    dim (Int): List/array of days in milk (DIM).\n    milkrecordings (Float): List/array of milk recordings (kg).\n    model (Str): Model name (lowercase), default \"wood\".\n        Supported for frequentist: \"wood\", \"wilmink\", \"ali_schaeffer\", \"fischer\", \"milkbot\".\n    fitting (Str): \"frequentist\" (default) or \"bayesian\".\n        Bayesian fitting is currently implemented only for \"milkbot\".\n    breed (Str): \"H\" (Holstein, default) or \"J\" (Jersey). Only used for Bayesian.\n    parity (Int): Lactation number; all parities &gt;= 3 considered one group in priors (Bayesian).\n    continent (Str): Prior source for Bayesian, \"USA\" (default), \"EU\", or \"CHEN\".\n    key (Str | None): API key for MilkBot (required when <code>fitting == \"bayesian\"</code>).</p>\n\n<p>Returns:\n    List/array of predicted milk yield for DIM 1\u2013305 (or up to the maximum DIM if &gt; 305).</p>\n\n<p>Raises:\n    Exception: If an unknown model is requested (frequentist),\n        or Bayesian is requested for a non-MilkBot model,\n        or <code>key</code> is missing when Bayesian fitting is requested.</p>\n\n<p>Notes:\n    Uses <code>validate_and_prepare_inputs</code> for input checking and normalization.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim</span>,</span><span class=\"param\">\t<span class=\"n\">milkrecordings</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;wood&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">fitting</span><span class=\"o\">=</span><span class=\"s1\">&#39;frequentist&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">breed</span><span class=\"o\">=</span><span class=\"s1\">&#39;H&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">parity</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">continent</span><span class=\"o\">=</span><span class=\"s1\">&#39;USA&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.get_chen_priors", "modulename": "lactationcurve", "qualname": "get_chen_priors", "kind": "function", "doc": "<p>Return Chen et al. priors in MilkBot format.</p>\n\n<p>Args:\n    parity: Lactation number (1, 2, or &gt;= 3).</p>\n\n<p>Returns:\n    Dictionary with parameter priors:\n    - \"scale\": {\"mean\", \"sd\"}\n    - \"ramp\": {\"mean\", \"sd\"}\n    - \"decay\": {\"mean\", \"sd\"}\n    - \"offset\": {\"mean\", \"sd\"}\n    - \"seMilk\": Standard error of milk measurement.\n    - \"milkUnit\": Unit string (e.g., \"kg\").</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parity</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.get_lc_parameters", "modulename": "lactationcurve", "qualname": "get_lc_parameters", "kind": "function", "doc": "<p>Fit lactation data to a model and return fitted parameters (frequentist).</p>\n\n<p>Depending on <code>model</code>, this uses <code>scipy.optimize.minimize</code> and/or\n<code>scipy.optimize.curve_fit</code> with model-specific starting values and bounds.</p>\n\n<p>Args:\n    dim (int): List/array of DIM values.\n    milkrecordings (float): List/array of milk recordings (kg).\n    model (str): One of \"wood\", \"wilmink\", \"ali_schaeffer\", \"fischer\", \"milkbot\".</p>\n\n<p>Returns:\n    Fitted parameters as floats, in alphabetical order by parameter name:\n        - wood: (a, b, c)\n        - wilmink: (a, b, c, k) with k fixed at -0.05\n        - ali_schaeffer: (a, b, c, d, k)\n        - fischer: (a, b, c)\n        - milkbot: (a, b, c, d)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dim</span>, </span><span class=\"param\"><span class=\"n\">milkrecordings</span>, </span><span class=\"param\"><span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;wood&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.get_lc_parameters_least_squares", "modulename": "lactationcurve", "qualname": "get_lc_parameters_least_squares", "kind": "function", "doc": "<p>Fit lactation data and return model parameters (least squares; frequentist).</p>\n\n<p>This helper uses <code>scipy.optimize.least_squares</code> to fit the MilkBot model with bounds,\nand returns the fitted parameters. \nCurrently implemented only for the MilkBot model, as it is more complex and benefits from the robust optimization approach. \nOther models can be fitted using <code>get_lc_parameters</code> with numerical optimisation, which is generally faster for simpler models.</p>\n\n<p>Args:\n    dim (int): List/array of DIM values.\n    milkrecordings (float): List/array of milk recordings (kg).\n    model (str): Pre-defined model name; currently used with \"milkbot\".</p>\n\n<p>Returns:\n    Parameters <code>(a, b, c, d)</code> as <code>np.float</code> in alphabetic order.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dim</span>, </span><span class=\"param\"><span class=\"n\">milkrecordings</span>, </span><span class=\"param\"><span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;milkbot&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.hayashi_model", "modulename": "lactationcurve", "qualname": "hayashi_model", "kind": "function", "doc": "<p>Hayashi lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM).\n    a: Ratio parameter (&gt; 0) (numerical).\n    b: Scale parameter (numerical).\n    c: Time constant for the first exponential term (numerical).\n    d: Parameter retained for compatibility with literature (unused in this expression).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n\n<p>Notes:\n    Formula: <code>y(t) = b * (exp(-t / c) - exp(-t / (a * c)))</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.milkbot_model", "modulename": "lactationcurve", "qualname": "milkbot_model", "kind": "function", "doc": "<p>MilkBot lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM), scalar or array-like.\n    a: Scale; overall level of milk production.\n    b: Ramp; governs the rate of rise in early lactation.\n    c: Offset; small (usually minor) correction around the theoretical start of lactation.\n    d: Decay; exponential decline rate, evident in late lactation.</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code> (same shape as <code>t</code>).</p>\n\n<p>Notes:\n    Formula: <code>y(t) = a * (1 - exp((c - t) / b) / 2) * exp(-d * t)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.nelder_model", "modulename": "lactationcurve", "qualname": "nelder_model", "kind": "function", "doc": "<p>Nelder lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM).\n    a: Denominator intercept (numerical).\n    b: Denominator linear coefficient (numerical).\n    c: Denominator quadratic coefficient (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n\n<p>Notes:\n    Formula: <code>y(t) = t / (a + b*t + c*t**2)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.prasad_model", "modulename": "lactationcurve", "qualname": "prasad_model", "kind": "function", "doc": "<p>Prasad lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM).\n    a: Intercept-like parameter (numerical).\n    b: Linear coefficient (numerical).\n    c: Quadratic coefficient (numerical).\n    d: Inverse-time coefficient (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n\n<p>Notes:\n    Formula: <code>y(t) = a + b*t + c*t**2 + d/t</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.rook_model", "modulename": "lactationcurve", "qualname": "rook_model", "kind": "function", "doc": "<p>Rook lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM).\n    a: Scale parameter (numerical).\n    b: Shape parameter in rational term (numerical).\n    c: Offset parameter in rational term (numerical).\n    d: Exponential decay parameter (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n\n<p>Notes:\n    Formula: <code>y(t) = a * (1 / (1 + b / (c + t))) * exp(-d * t)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.sikka_model", "modulename": "lactationcurve", "qualname": "sikka_model", "kind": "function", "doc": "<p>Sikka lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM).\n    a: Scale parameter (numerical).\n    b: Growth parameter (numerical).\n    c: Quadratic decay parameter (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.wilmink_model", "modulename": "lactationcurve", "qualname": "wilmink_model", "kind": "function", "doc": "<p>Wilmink lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM), scalar or array-like.\n    a: Intercept-like parameter (numerical).\n    b: Linear trend coefficient (numerical).\n    c: Exponential-term scale (numerical).\n    k: Fixed exponential rate (numerical), default -0.05.</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n\n<p>Notes:\n    Formula: <code>y(t) = a + b * t + c * exp(k * t)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"o\">=-</span><span class=\"mf\">0.05</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.wood_model", "modulename": "lactationcurve", "qualname": "wood_model", "kind": "function", "doc": "<p>Wood lactation curve model.</p>\n\n<p>Args:\n    t: Time since calving in days (DIM), scalar or array-like.\n    a: Scale parameter (numerical).\n    b: Shape parameter controlling rise (numerical).\n    c: Decay parameter (numerical).</p>\n\n<p>Returns:\n    Predicted milk yield at <code>t</code>.</p>\n\n<p>Notes:\n    Formula: <code>y(t) = a * t**b * exp(-c * t)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.calculate_characteristic", "modulename": "lactationcurve", "qualname": "calculate_characteristic", "kind": "function", "doc": "<p>Evaluate a lactation curve characteristic from observed test-day data.</p>\n\n<p>This function fits the requested model (frequentist or Bayesian via MilkBot),\nretrieves model parameters, and evaluates the requested characteristic using the\nsymbolic expression (if available), falling back to numeric methods when needed.</p>\n\n<p>Args:\n    dim (Int): Days in milk (DIM).\n    milkrecordings (Float): Milk recordings (kg or lbs) for each DIM.\n    model (str): Model name. Supported for this function:\n        'milkbot', 'wood', 'wilmink', 'ali_schaeffer', 'fischer'.\n    characteristic (str): One of 'time_to_peak', 'peak_yield', 'cumulative_milk_yield', 'persistency'.\n    fitting (str): 'frequentist' (default) or 'bayesian'.\n    key (str | None): API key for MilkBot Bayesian fitting.\n    parity (Int): Parity of the cow; values above 3 are considered as 3 (Bayesian).\n    breed (str): 'H' (Holstein) or 'J' (Jersey) (Bayesian).\n    continent (str): 'USA', 'EU', or 'CHEN' (Bayesian).\n    persistency_method (str): 'derived' (average slope after peak; default) or 'literature'\n        (only for Wood and MilkBot).\n    lactation_length (Int | str): Horizon for persistency calculation:\n        305 (default), 'max' (use max DIM in data), or an integer.</p>\n\n<p>Returns:\n    float: The requested characteristic value.</p>\n\n<p>Raises:\n    Exception: If inputs are invalid, the model/characteristic is unsupported,\n        an API key is missing for Bayesian fitting, or the characteristic cannot be computed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim</span>,</span><span class=\"param\">\t<span class=\"n\">milkrecordings</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;wood&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">characteristic</span><span class=\"o\">=</span><span class=\"s1\">&#39;cumulative_milk_yield&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">fitting</span><span class=\"o\">=</span><span class=\"s1\">&#39;frequentist&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">parity</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">breed</span><span class=\"o\">=</span><span class=\"s1\">&#39;H&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">continent</span><span class=\"o\">=</span><span class=\"s1\">&#39;USA&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">persistency_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;derived&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">lactation_length</span><span class=\"o\">=</span><span class=\"mi\">305</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.lactation_curve_characteristic_function", "modulename": "lactationcurve", "qualname": "lactation_curve_characteristic_function", "kind": "function", "doc": "<p>Build (or fetch from cache) a symbolic expression and fast numeric function for an LCC.</p>\n\n<p>This function derives the requested <strong>lactation curve characteristic</strong> for a given\nmodel using SymPy (derivative / root finding / integration). It returns the symbolic\nexpression, the tuple of parameter symbols (argument order), and a lambdified\nnumeric function that can be evaluated with numerical parameters.</p>\n\n<p>The symbolic derivation and integration are done only once per (model, characteristic)\nand then <strong>cached</strong> for reuse.</p>\n\n<p>Args:\n    model (str): Model name. Options:\n        'milkbot', 'wood', 'wilmink', 'ali_schaeffer', 'fischer',\n        'brody', 'sikka', 'nelder', 'dhanoa', 'emmans', 'hayashi',\n        'rook', 'dijkstra', 'prasad'.\n    characteristic (str | None): Desired characteristic. Options:\n        'time_to_peak', 'peak_yield', 'cumulative_milk_yield', 'persistency'.\n        If <code>None</code> or unrecognized, a dict of all available characteristics is returned\n        (with <code>persistency</code> possibly <code>None</code> if derivation is not feasible).\n    lactation_length (int): Length of lactation in days used in persistency\n        computation (default 305).</p>\n\n<p>Returns:\n    tuple:\n        expr: SymPy expression (or dict of expressions if <code>characteristic</code> is None).\n        params: Tuple of SymPy symbols for model parameters (argument order).\n        func: Lambdified numeric function <code>f(*params)</code> (or dict of functions).</p>\n\n<p>Raises:\n    Exception: If the model is unknown, or if no positive real solution for\n        peak timing/yield exists where required.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;wood&#39;</span>, </span><span class=\"param\"><span class=\"n\">characteristic</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">lactation_length</span><span class=\"o\">=</span><span class=\"mi\">305</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.numeric_cumulative_yield", "modulename": "lactationcurve", "qualname": "numeric_cumulative_yield", "kind": "function", "doc": "<p>Compute cumulative milk yield numerically over a given horizon.</p>\n\n<p>Adds up the fitted milk yield for the first <code>lactation_length</code> days of the\npredicted yield curve.</p>\n\n<p>Args:\n    dim: DIM values.\n    milkrecordings: Milk recordings (kg).\n    model: Model name.\n    fitting: 'frequentist' or 'bayesian'.\n    lactation_length: Number of days to integrate (default 305).\n    **kwargs: Additional arguments forwarded to <code>fit_lactation_curve</code>.</p>\n\n<p>Returns:\n    float: Cumulative milk yield over the specified horizon.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim</span>,</span><span class=\"param\">\t<span class=\"n\">milkrecordings</span>,</span><span class=\"param\">\t<span class=\"n\">model</span>,</span><span class=\"param\">\t<span class=\"n\">fitting</span><span class=\"o\">=</span><span class=\"s1\">&#39;frequentist&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">lactation_length</span><span class=\"o\">=</span><span class=\"mi\">305</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.numeric_peak_yield", "modulename": "lactationcurve", "qualname": "numeric_peak_yield", "kind": "function", "doc": "<p>Compute peak yield numerically from the fitted curve.</p>\n\n<p>Args:\n    dim: DIM values.\n    milkrecordings: Milk recordings (kg).\n    model: Model name.\n    fitting: 'frequentist' or 'bayesian'.\n    key: API key for MilkBot (Bayesian).\n    parity: Parity for Bayesian fitting.\n    breed: Breed for Bayesian fitting ('H' or 'J').\n    continent: Prior source for Bayesian ('USA', 'EU', 'CHEN').</p>\n\n<p>Returns:\n    float: Maximum predicted milk yield.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim</span>,</span><span class=\"param\">\t<span class=\"n\">milkrecordings</span>,</span><span class=\"param\">\t<span class=\"n\">model</span>,</span><span class=\"param\">\t<span class=\"n\">fitting</span><span class=\"o\">=</span><span class=\"s1\">&#39;frequentist&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">parity</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">breed</span><span class=\"o\">=</span><span class=\"s1\">&#39;H&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">continent</span><span class=\"o\">=</span><span class=\"s1\">&#39;USA&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.numeric_time_to_peak", "modulename": "lactationcurve", "qualname": "numeric_time_to_peak", "kind": "function", "doc": "<p>Compute time to peak using a numeric approach.</p>\n\n<p>Fits the curve (frequentist or Bayesian), evaluates the predicted yields,\nand returns the DIM corresponding to the maximum predicted yield.</p>\n\n<p>Args:\n    dim: DIM values.\n    milkrecordings: Milk recordings (kg).\n    model: Model name.\n    fitting: 'frequentist' or 'bayesian'.\n    key: API key for MilkBot (Bayesian).\n    parity: Parity for Bayesian fitting.\n    breed: Breed for Bayesian fitting ('H' or 'J').\n    continent: Prior source for Bayesian ('USA', 'EU', 'CHEN').</p>\n\n<p>Returns:\n    int: DIM at which the curve attains its maximum (1-indexed).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim</span>,</span><span class=\"param\">\t<span class=\"n\">milkrecordings</span>,</span><span class=\"param\">\t<span class=\"n\">model</span>,</span><span class=\"param\">\t<span class=\"n\">fitting</span><span class=\"o\">=</span><span class=\"s1\">&#39;frequentist&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">parity</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">breed</span><span class=\"o\">=</span><span class=\"s1\">&#39;H&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">continent</span><span class=\"o\">=</span><span class=\"s1\">&#39;USA&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.persistency_fitted_curve", "modulename": "lactationcurve", "qualname": "persistency_fitted_curve", "kind": "function", "doc": "<p>Persistency as the average slope after peak until end of lactation (numeric).</p>\n\n<p>This is the default approach because symbolic derivation is not feasible for\nall models. It computes:\n    <code>(yield_at_end - yield_at_peak) / (lactation_length - time_to_peak)</code></p>\n\n<p>Args:\n    dim: DIM values.\n    milkrecordings: Milk recordings (kg).\n    model: Model name. Options include 'milkbot' (Bayesian or frequentist),\n        'wood', 'wilmink', 'ali_schaeffer', 'fischer'.\n    fitting: 'frequentist' or 'bayesian'.\n    key: API key (only for Bayesian fitting).\n    parity: Parity of the cow; values above 3 treated as 3 (Bayesian).\n    breed: 'H' or 'J' (Bayesian).\n    continent: 'USA', 'EU', or 'CHEN' (Bayesian).\n    lactation_length (int | str): 305 (default), 'max' (use max DIM), or integer.</p>\n\n<p>Returns:\n    float: Average slope after the peak until end of lactation.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim</span>,</span><span class=\"param\">\t<span class=\"n\">milkrecordings</span>,</span><span class=\"param\">\t<span class=\"n\">model</span>,</span><span class=\"param\">\t<span class=\"n\">fitting</span><span class=\"o\">=</span><span class=\"s1\">&#39;frequentist&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">parity</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">breed</span><span class=\"o\">=</span><span class=\"s1\">&#39;H&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">continent</span><span class=\"o\">=</span><span class=\"s1\">&#39;USA&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">lactation_length</span><span class=\"o\">=</span><span class=\"mi\">305</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.persistency_milkbot", "modulename": "lactationcurve", "qualname": "persistency_milkbot", "kind": "function", "doc": "<p>Persistency from the MilkBot model (Ehrlich, 2013): <code>Persistency = 0.693 / d</code>.</p>\n\n<p>Args:\n    d (float): Parameter <code>d</code> of the MilkBot model.</p>\n\n<p>Returns:\n    float: Persistency value from the MilkBot formula.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.persistency_wood", "modulename": "lactationcurve", "qualname": "persistency_wood", "kind": "function", "doc": "<p>Persistency from Wood et al. (1984): <code>Persistency = -(b + 1) * ln(c)</code>.</p>\n\n<p>Args:\n    b (float): Parameter <code>b</code> of the Wood model.\n    c (float): Parameter <code>c</code> of the Wood model.</p>\n\n<p>Returns:\n    float: Persistency value from the Wood formula.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "lactationcurve.test_interval_method", "modulename": "lactationcurve", "qualname": "test_interval_method", "kind": "function", "doc": "<p>Compute 305-day total milk yield using the ICAR Test Interval Method.</p>\n\n<p>The method applies:</p>\n\n<ul>\n<li>Linear projection from calving to the first test day,</li>\n<li>Trapezoidal integration between consecutive test days,</li>\n<li>Linear projection from the last test day to DIM=305.</li>\n</ul>\n\n<p>Args:\n    df (pd.DataFrame): Input DataFrame with at least DaysInMilk, MilkingYield,\n        and (optionally) TestId columns (names can be provided via arguments\n        or matched via known aliases, case-insensitive).\n    days_in_milk_col (str | None): Optional column name override for DaysInMilk.\n    milking_yield_col (str | None): Optional column name override for MilkingYield.\n    test_id_col (str | None): Optional column name override for TestId.\n    default_test_id (Any): If TestId is missing, a new <code>TestId</code> column is created\n        with this value.</p>\n\n<p>Returns:\n    pd.DataFrame: Two-column DataFrame with\n        - \"TestId\": identifier per lactation,\n        - \"Total305Yield\": computed total milk yield over 305 days.</p>\n\n<p>Raises:\n    ValueError: If required columns (DaysInMilk or MilkingYield) cannot be found.</p>\n\n<p>Notes:\n    - Records with DIM &gt; 305 are dropped before computation.\n    - At least two data points per TestId are required for trapezoidal integration;\n      otherwise the lactation is skipped.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">days_in_milk_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">milking_yield_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">test_id_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">default_test_id</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();
